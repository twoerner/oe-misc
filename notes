vim: expandtab ts=4 sts=4 sw=4 textwidth=78 colorcolumn=78

Index:
    46. How to make a recipe MACHINE-specific
    45. Multilib build (mix 64- and 32-bit)
    44. Build for selected architectures only
    43. Switch to systemd
    42. Adding kernel modules
    41. Inter-task/recipe locks (e.g. restricting the number of fetches)
    40. Pretty buildstats charts
    39. Add a full python to the SDK
    38. Adding (and using) the linaro toolchain
    37. Scheduling inter-recipe tasks
    36. Post-process
    35. Tasks
    34. Bad shared libraries
    33. Building/using an initramfs
    32. Debugging app on target with gdb on dev host
    31. Working with sstate stamps
    30. Autotools build where $B != $S
    29. Invoking the host's compiler while cross-compiling
    28. Disabling parallel build
    27. Using the package feed from a build machine on a target device
        27.a ipk/opkg
    26. devshell environment
    25. Faulty host tools (buildtools-tarball)
    24. Removing a package
    23. bmaptool
    22. Cleaning up
    21. Investigating variables
    20. menuconfig
    19. SDK
        19.a ADT
        19.b populate_sdk
        19.c meta-toolchain
        19.d native development
        19.e manual Makefile
    18. Image package list
    17. Notes for imx53qsb
    16. Notes on setting up an ssh server in an image
    15. Setting the size of an image
    14. Ignoring .bbappends with no .bb
    13. Ignoring certain configuration items
    12. To obtain a list of supported output image types
    11. Recipe dependency information
    10. How to restart the build when a recipe fails
     9. How to modify the autotool ./configure options
     8. How to add packages to an image
     7. How to build an image with an -rt kernel
     6. - removed -
     5. Quick start instructions
     4. How can I just grab all the necessary files from the net?
     3. What images are available from which to choose?
     2. General task list
     1. How to obtain the list of tasks


==============================================================================
46. How to make a recipe MACHINE-specific

    PACKAGE_ARCH = "${MACHINE_ARCH}"

==============================================================================
45. Multilib build (mix 64- and 32-bit)

    If the overall build is 64-bit but you want to build one app 32-bit:

        $ bitbake lib32-<your app>

==============================================================================
44. Build for selected architectures only

    To enable specific architectures and disallow all others:

        COMPATIBLE_MACHINE = "(-)"
        COMPATIBLE_MACHINE_x86 = "(.*)"
        COMPATIBLE_MACHINE_x86-64 = "(.*)"
        COMPATIBLE_MACHINE_armv6 = "(.*)"
        COMPATIBLE_MACHINE_armv7a = "(.*)"

    In this case we allow x86, x86-64, armv6, and armv7, but disallow all
    others.

    To allow all architectures but turn off specific ones (a sort of
    "INCOMPATIBLE_MACHINE", if you will...):

        COMPATIBLE_MACHINE_armv4 = "(!.*armv4).*"
        COMPATIBLE_MACHINE_armv5 = "(!.*armv5).*"
        COMPATIBLE_MACHINE_mips64 = "(!.*mips64).*"

    Here armv4, armv5, and mips64 are not allowed, but by default anything
    else is.


==============================================================================
43. Switch to systemd

    Add the following the local.conf:

        DISTRO_FEATURES_append = " systemd"
        DISTRO_FEATURES_BACKFILL_CONSIDERED += "sysvinit"
        VIRTUAL-RUNTIME_init_manager = "systemd"
        VIRTUAL-RUNTIME_initscripts = "systemd-compat-units"


==============================================================================
42. Adding kernel modules

    By default no kernel modules are included in an image, which allows you to
    choose which ones (individually) to package. If you want to add all the
    default modules to an image:

        MACHINE_EXTRA_RRECOMMENDS = " kernel-modules"

    to machine.conf (or local.conf?). To select modules individually use:

        IMAGE_INSTALL += "kernel-module-<name>"


==============================================================================
41. Inter-task/recipe locks (e.g. restricting the number of fetches)

    Apparently it's possible to set a lock such that any task that uses the
    same lock will have to wait for it to be available(!). This allows a user,
    for example, to setup a lock for all fetch tasks so that they no longer
    occur in parallel:

        do_fetch[lockfiles] += "${TMPDIR}/myfetch.lock"

    The name isn't critical, it just needs to be the same in all of the
    recipes you wish to have participate in this exclusive fetching.

    https://lists.yoctoproject.org/pipermail/yocto/2015-July/025418.html


==============================================================================
40. Pretty buildstats charts

    A while back (2011) Richard Purdie added the functionality to display
    detailed, graphical profiles of a build, heavily borrowed from the Linux
    kernel's "pybootchartgui" functionality.

    To get your build to generate the needed data, make sure "buildstats" is
    included in USER_CLASSES.

    Once your build completes, run:

        $ path/to/meta-poky/scripts/pybootchartgui/pybootchartgui.py $TMPDIR/buildstats/<image>-<$MACHINE>

    e.g.

        $ ~/devel/yocto/releases/master/layers/meta-poky/scripts/pybootchartgui/pybootchartgui.py tmp/buildstats/core-image-full-cmdline-beaglebone

    Some suggested cmdline options to pybootchartgui.py are:

        $ <command> <image arg> \
                -f svg \
                -s 5 \
                -o /tmp

        -f <FORMAT>     specify a FORMAT, one of svg, pdf, png (default)
        -s <NUM>        split the output into <NUM> files
        -o <DIR>        place the output into file(s) at <DIR>

==============================================================================
39. Add a full python to the SDK

    The python that gets added to the SDK is rather minimal, to add a "full"
    python to your "-c populate_sdk" add the following to your config:

        TOOLCHAIN_HOST_TASK_append = " nativesdk-python-modules"

    see: https://lists.yoctoproject.org/pipermail/yocto/2015-April/024446.html

==============================================================================
38. Adding (and using) the linaro toolchain

    When working with ARM device (specifically CortexA) the base OE layers
    contain the necessary bits to create a working cross-compiler. But since
    Linaro specializes in ARM and ARM toolchains you might find the Linaro GCC
    toolchain is: more up to date, has better SoC support, has more fixes, has
    more testing, ...

    To use the linaro toolchain is quite simple:
        - add the linaro layer to your bblayers
        - tell bitbake to prefer it to the base toolchain

    $ bitbake-layers add <path to meta-linaro/meta-linaro-toolchain>

    Then edit conf/local.conf and add:

        GCCVERSION = "linaro-4.9%"
        SDKGCCVERSION = "linaro-4.9%"

==============================================================================
37. Scheduling inter-recipe tasks

    https://www.mail-archive.com/openembedded-devel@lists.openembedded.org/msg41478.html

    Q. Is it possible to mark two or more tasks to run exclusive?
       IOW, is it possible to schedule a task in one recipe relative to a task
       in another recipe?

    A. e.g.

        do_fetch[depends] += "xxx:do_fetch"

        Put this in the bb/bbappend of one recipe, "xxx" is the other recipe.

==============================================================================
36. Post-process

    To do post-processing tweaks to an image before it gets packaged up into
    an image, see:

        IMAGE_POSTPROCESS_COMMAND

    e.g. remove /etc/version from image:

        remove_etc_version() {
            rm ${IMAGE_ROOTFS}${sysconfdir}/version
        }
        ROOTFS_POSTPROCESS_COMMAND += "remove_etc_version ; "

==============================================================================
35. Tasks

    In base.bbclass we have the following fundamental tasks:

        do_fetch
        do_unpack
        do_configure
        do_compile
        do_install
        do_package

    A task can be completely replaced (class and/or recipe):

        do_install () {
            oe_runmake 'DESTDIR=${D}' install
        }

    You can also add to a task (before or after) by using "_prepend" or
    "_append":

        do_install_append () {
            ...
        }

        do_configure_prepend () {
            ...
        }

    There are 3 ways a task can be removed:

    1) NULLing out the contents:

        do_configure () {
            :
        }

    2) using "noexec":

        do_fetch[noexec] = "1"

    3) using "deltask":

        deltask configure

==============================================================================
34. Bad shared libraries

    Some packages mistakenly create shared libraries that end with "*.so"
    instead of "*.so.<maj><min>". In this case the default classes will scoop
    up these "*.so" files and put them in the -dev package. To avoid this:

        FILES_${PN} += "${libdir}/*.so"
        FILES_SOLIBSDEV = ""
        INSANE_SKIP_${PN} += "dev-so"

        - or -

        FILES+SOLIBSDEV = ""
        SOLIBS = ".so"
        INSANE_SKIP_${PN} += "dev-so"

==============================================================================
33. Building/using an initramfs

    OE has:

        COMPATIBLE_HOST = "(i.86|x86_64).*-linux

    as part of core-image-minimal-initramfs so it will only work if the target
    is x86-based. However, initramfs'es can still be used for other
    architectures. Simply add "cpio" to IMAGE_FSTYPES and use the resulting
    cpio archive as the initrd. The above only means this specific image
    (core-image-minimal-initramfs) was meant only to run on x86-based targets,
    not that other targets can't have initramfs'es.

    Khem also points out you can make any image become an initramfs image by
    adding:

        INITRAMFS_IMAGE = "your-initramfs-image"
        INITRAMFS_IMAGE_BUNDLE = "1"

    Adam initially ended up with an initramfs cpio image of 69MB in size!
    However he then noticed he had some unnecessary DISTRO_FEATURES enabled;
    once they were disabled the image shrunk to 2.5MB.

==============================================================================
32. Debugging app on target with gdb on dev host

    (email on oedev mailing list, info from Mats Karrman)

    "
    Prerequisites:
    - a network connection between your target and your development host (it's
      possible to use a tty too).
    - OE built SDK installed on your host.
    - gdbserver package installed on your target.
    - your binary (my-program) on target
    - an unstripped version of your binary in the working directory on host.

    The exact commands below will vary with the install path of your SDK
    (/usr/local/oecore-x86_64 in my case) and target specifics (e.g. powerpc,
    ppce300c3... in my case).

    On target:
    # gdbserver :2345 my-program

    On host:
    $ source /usr/local/oecore-x86_64/environment-setup-ppce300c3-oe-linux
    $ powerpc-oe-linux-gdb my-program
    (gdb) set sysroot /usr/local/oecore-x86_64/sysroots/ppce300c3-oe-linux
    (gdb) target remote <target-ip>:2345
    (gdb) br main
    (gdb) cont
    ...
    "
==============================================================================
31. Working with sstate stamps

    Mike Looijmans asked a question on the mailing list about sstate.
    Specifically he wants to share sstate across two (or more) build machines.
    The second build on another machine, however, insists on rebuilding even
    though it shouldn't. Richard Purdie provides tonnes of useful information:

    "
    Let me explain the manual process you can follow for this. Its a pain to
    walk through and its what -S attempts to automate but you should be able
    to get an answer manually this way.

    You have BUILDA and BUILDB, the two builds which should be reusing
    sstate but are not. The fact they're on different machines is irrelevant
    to this procedure. It would help if these two builds are just the result
    of "bitbake fpga-image-miami" but that isn't essential, it will just
    introduce more noise. It will also help if they are either both built
    from an existing sstate cache or both not.

    The first thing I'd do in each build:

        $ find tmp/stamps/ -type f | sort > stamplistA.txt

    I'd then so something like:

        $ meld stamplistA stamplistB

    the next steps depend upon how clear the differences are. Basically
    there should be some degree of commonality between the two builds and at
    some point there will be divergence. We need to pinpoint the point of
    divergence. The divergence will be in fpga-image-miami itself or in one
    of its dependencies.

    The one thing which can confuse this view is if some things were reused
    from sstate. You can tell since a task which runs looks like:

        tmp/stamps/i586-poky-linux/x11-common/0.1-r47.do_populate_sysroot.d90d4404368125acd109a2ac64ca688f.qemux86

    and a task which is from sstate looks like:

        tmp/stamps/all-poky-linux/gstreamer1.0-meta-base/1.0-r0.do_populate_sysroot_setscene.a49fa811727c557c14ab6ce6f2973587.qemux86

    The "_setscene" part tells you this. Machine specific tasks have the
    machine name appended to them ".qemux86" in this case. The hash
    representing the task is clear in the filename
    ("a49fa811727c557c14ab6ce6f2973587" in this case").

    You'll have to filter out any "noise" from these changes you're not
    interested in. If a task is "_setscene" its dependencies may be missing
    from the list of files entirely (no install/compile/configure etc.).

    So you take a guess at the divergence point and take note of the two
    different hashes. You can then find the corresponding siginfo files in
    sstate:

        $ find sstate-cache/ -name *d90d4404368125acd109a2ac64ca688f*
        sstate-cache/d9/sstate:x11-common:i586-poky-linux:0.1:r47:i586:3:d90d4404368125acd109a2ac64ca688f_populate_sysroot.tgz
        sstate-cache/d9/sstate:x11-common:i586-poky-linux:0.1:r47:i586:3:d90d4404368125acd109a2ac64ca688f_populate_sysroot.tgz.siginfo

    which are the sstate files corresponding to my above x11-common task.
    You will note that the first two letters of the hash are used as a
    directory prefix. You can also find sigdata files in the stamp
    directory:

        $ find tmp/stamps/ -type f | grep d90d440
        tmp/stamps/i586-poky-linux/x11-common/0.1-r47.do_populate_sysroot.d90d4404368125acd109a2ac64ca688f.qemux86
        tmp/stamps/i586-poky-linux/x11-common/0.1-r47.do_populate_sysroot.sigdata.d90d4404368125acd109a2ac64ca688f

    The sigdata and siginfo files are identical and equivalent. Once you
    have the two sstate files, you can run:

        $ bitbake-diffsigs A.siginfo B.siginfo

    and this will tell you why their hashes are different. If you need help
    deciphering that output, link to it and I can help.

    If you didn't guess the divergence point correctly, it will tell you
    that some prior task is actually different. In that case you would then
    go and fetch the siginfo tasks for the previous task and compare those.
    Either you find the difference or again, you have to trace it further
    back.
    "

    Mike replies (in part) with:

    "
    So far, on one project (that is, NOT the fpga-image-miami) the
    SRC_URI is slightly different. The machines are on various sides of
    a router/firewall, so SRC_URI="git://${MY_SERVER}/blabla" evaluates
    differently.

    How can I tell the system that the value of "MY_SERVER" is irrelevant to
    each and every build step in each and every recipe?
    "

    To which Richard replies:

    "
    The SRC_URI changing would indeed cause the tasks build separately since
    bitbake thinks they're different things.

    You have two ways of addressing this. Firstly, you could setup PREMIRROR
    entries for these git urls which remaps them to the correct thing in
    each case. There would then be one "canonical" url in the recipe and
    you'd not need to change the hash generation.

    The other way would be to either exclude the variable from the checksum
    generation or give it a specific value. This would be something like:

        do_fetch[vardepsexclude] += "SRC_URI"

    you may also have to do this with other tasks that use SRC_URI such as
    do_unpack and do_patch.

    The other option is:

        SRC_URI[vardepvalue] = "git://canonical/url/for/recipe"

    which gives it a specific value to use for checksum purposes.
    "


    Chris Larson (in a completely unrelated thread) also points out:

        "bitbake -S printdiff <target>" will tell you why the sstate wasn't
        used (where <target> is: a specific recipe, your image, whatever). You
        might need https://gist.github.com/kergoth/3713d779c14dc8b98f36

    Martin Jansa says:
        try "openembedded-core/scripts/sstate-diff-machines.sh" to see why

    Also:
        $ bitbake-whatchanged -v <your image>

==============================================================================
30. Autotools build where $B != $S

    Replace

        inherit autotools

    with

        inherit autotools-brokensep

==============================================================================
29. Invoking the host's compiler while cross-compiling

    Search for/investigate: BUILD_CC

==============================================================================
28. Disabling parallel build

    Sometimes a package builds perfectly fine using a parallel build (i.e. for
    values of N in 'make -jN' greater than 1). But other times (usually due to
    a badly constructed Makefile, such as when dependencies are not fully or
    properly described) a build must be forced to build "serially" in order to
    succeed.

    In these cases, add the following to the recipe:

        PARALLEL_MAKE = ""

==============================================================================
27. Using the package feed from a build machine on a target device

    In order to use package management on your device, you need a way to serve
    up the package set which is built on the build machine. Typically this is
    done via HTTP. A simple and easy-to-use HTTP server is "lighttpd".

    One of the key things to know is that, on the build machine, you must run:

        $ bitbake package-index

    after any change that might affect packaging or after any rebuild. NOTE
    that the following invocation:

        $ bitbake <some package> package-index

    doesn't work since "package-index" must run at the very end, and the
    dependencies aren't in place to enforce this. Therefore it is safest to
    just simply invoke "bitbake package-index" by itself at the end of any
    build.

 27.a) ipk/opkg

    Build Machine Setup

        Regardless of which HTTP server you use, you'll need to figure out the
        location from which it serves its files. This is usually described in
        its configuration files as the "document root". Once you know this
        location you'll probably want to create a symbolic link from your
        $TMPDIR/deploy/ipk to the server's document root:

            # ln -s ${PWD}/tmp/deploy/ipk /srv/www/htdocs/MYBOARD-files

        In your target's configuration you'll also need to add "opkg" to its
        image. For example, in conf/local.conf you could add:

            CORE_IMAGE_EXTRA_INSTALL += "opkg"

        NOTE that it is not necessary to add "package-management" to
        EXTRA_IMAGE_FEATURES unless you want your board to start off with the
        base package information that would be known at the end of the build.
        If this is the case then you don't need to explicitly add "opkg" to
        the image since this will be done by default by EXTRA_IMAGE_FEATURES.

        As noted below (in the "Target Machine Usage" section), you'll need
        to provide *.conf files on your target device in order to find
        the package feeds. To make the process of creating the on-target
        configuration files easier, meta-oe provides a recipe named
        "distro-feed-configs" which you can include in your image which will
        generate the /etc/opkg *.conf files and include them in your image.

        In order to use this facility you'll need to do the following in your
        conf/local.conf:

            - add "distro-feed-configs" to your image:

                CORE_IMAGE_EXTRA_INSTALL += "distro-feed-configs"

            - provide a base url for fetching:

                DISTRO_FEED_URI = "http://192.168.7.1/MYBOARD-files"

    Target Machine Usage

        On the target machine you need to have the "opkg" utility installed
        (which is done during the build either by including
        "package-management" in EXTRA_IMAGE_FEATURES or by adding the "opkg"
        recipe to the image).

        Next you need to have *.conf files in /etc/opkg which describe how and
        from where to fetch the various package feeds. For example you might
        create an "/etc/opkg/base-feeds.conf" file that looks like:

            src/gz remote-all http://mymachine.com/MYBOARD-files/all
            src/gz remote-armv7 http://mymachine.com/MYBOARD-files/armv7
            src/gz remote-qemuarm http://mymachine.com/MYBOARD-files/qemuarm

        However, if you included the "distro-feed-configs" package as part of
        your image, these configuration files will already be included in your
        image and you won't have to create this file yourself.

        To refresh/update the ipk package management database on the target
        simply run:

            # opkg update

        This will pull and update the database entries. Now you are ready to
        install, remove, etc. any packages from the remote machine which is
        serving up the packages.

==============================================================================
26. devshell environment

    Trying to use the devshell feature had been giving me problems.

    To start, my default prompt strings were making use of some functions that
    I define in my ~/.bashrc; unfortunately these functions were not being
    copied into the devshell environment so my prompts were causing errors to
    be printed to the terminal.

    Secondly, I had setup a number of environment variables in such a way
    as to not expect any help from the "outside". For example my PATH
    export didn't bother to include $PATH in its definition because I know
    all the places I want my shell to look and don't need to add to an
    existing definition. The same was true for a number of other (ironically)
    build-related environment variables such as LD_LIBRARY_PATH, CPATH,
    PKG_CONFIG_PATH... As you can guess, this doesn't play well with devshell
    since the way it works is to set, for example, PATH and then load the
    user's settings. Since my settings weren't incorporating any existing
    PATH, all I'd get was whatever I had set in my ~/.bashrc.

    To get around this problem I made use of the "custom" OE_TERMINAL type and
    a specific bashrc file created specifically for devshell usage.

    First, take your existing ~/.bashrc and copy it to ~/.bashrc.oe. Edit
    ~/.bashrc.oe and remove anything that relies on defined functions or that
    sets a variable without incorporating its current definition.

    Second, create a script somewhere on your PATH containing:

        /bin/bash --rcfile /path/to/your/home/.bashrc.oe

    and make it executable.

    Finally in your conf/local.conf add the following lines:

        OE_TERMINAL = "custom"
        OE_TERMINAL_CUSTOMCMD = "/usr/bin/xterm -e /path/to/the/above/script"

==============================================================================
25. Faulty host tools (buildtools-tarball)

    make-3.82 is known to have issues. The build system now contains a sanity
    test to check not only your version of make, but can differentiate between
    make's which have been patched by your distro to avoid the known issue(s).

    If your distro fails this sanity test you can attempt to generate the
    buildtools-tarball which you can then use exactly as you would an SDK.

        $ bitbake buildtools-tarball

    You'll then find the result in ${TMPDIR}/deploy/sdk

        poky-eglibc-x86_64-i586-buildtools-nativesdk-standalone-1.4+snapshot-20130724.sh

    Simply run this self-extracting shell script and choose an install
    location:

        $ ./poky-eglibc-x86_64-i586-buildtools-nativesdk-standalone-1.4+snapshot-20130724.sh 
        Enter target directory for SDK (default: /opt/poky/1.4+snapshot): <enter DEST dir here>
        You are about to install the SDK to "<DEST>". Proceed[Y/n]?
        Extracting SDK...done
        Setting it up...done
        SDK has been successfully set up and is ready to be used.

    Just like when using an SDK, in the <DEST> directory you'll find an
    environment file which you can "source" to begin using the tools from the
    buildtools-tarball:

        $ source <DEST>/environment-setup-x86_64-pokysdk-linux
    
    If you don't trust your host system to correctly build the
    buildtools-tarball, you can download a known working one from:

        http://autobuilder.yoctoproject.org/pub/nightly/CURRENT/buildtools/

==============================================================================
24. Removing a package

    Use the BAD_RECOMMENDATIONS variable to list any packages that must be
    filtered out during image creation. NOTE: BAD_RECOMMENDATIONS only works
    for ipk.

==============================================================================
23. bmaptool

    bmaptool[1] is a utility which speeds up the creation of sdcard images.

    Without using bmaptools:
        $ time dd if=core-image-minimal-imx53qsb.sdcard of=/dev/sdf
        26034176+0 records in
        26034176+0 records out
        13329498112 bytes (13 GB) copied, 5340.82 s, 2.5 MB/s

        real    89m0.826s
        user    0m20.977s
        sys     3m51.128s

    Note that most of the above is just useless copying of blank/empty
    sectors.

    To use bmaptools two steps are required:
        1) create the map
            $ bmaptool create -o <bmapfile> <image>
        2) use the map to create the sdcard
            $ bmaptool copy --bmap <bmapfile> <image> <device>


    $ time bmaptool create -o sdcard.bmap core-image-minimal-imx53qsb.sdcard

    real    1m32.797s
    user    0m33.658s
    sys     0m6.001s


    $ time bmaptool copy \
        --bmap sdcard.bmap \
        core-image-minimal-imx53qsb.sdcard \
        /dev/sdf

    real    42m59.165s
    user    0m39.362s
    sys     0m22.307s



    [1] https://source.tizen.org/documentation/articles/bmaptool

==============================================================================
22. Cleaning up

    There are various ways to "clean":

        $ bitbake -c cleanall <recipe>
            - cleans working directory
            - cleans sstate
            - cleans (removes?) downloaded files

        $ bitbake -c cleansstate <recipe>
            - cleans sstate

        $ rm -fr <TMPDIR>
            - removes output files

==============================================================================
21. Investigating variables

    I often find myself wondering how a variable gets set, where it gets set,
    and the value to which it gets set. Or perhaps I might even wonder what
    variables are available.

    For these (and other such) questions, use:

        $ bitbake -e

    Usually you'll want to know the information for a given target, in which
    case you'd usually do:

        $ bitbake -e <image target>

    This generates a lot of data, so you'll probably want to pipe it through
    "less" or otherwise redirect it in some way.

    The output can be divided into roughly two sections: one section for
    variables, and the second for functions. Fortunately the variables
    come first. As one example, here is what this output gives for me for
    the variable OE_TERMINAL (which is a variable I have tweaked in my own
    conf/local.conf:

        # $OE_TERMINAL [4 operations]
        #   set /home/trevor/devel/yocto/gitrepo-method/fullbuild/conf/local.conf:28
        #     "screen"
        #   set? /home/trevor/devel/yocto/gitrepo-method/poky/meta/classes/terminal.bbclass:1
        #     "auto"
        #   set /home/trevor/devel/yocto/gitrepo-method/poky/meta/classes/terminal.bbclass:2
        #     [type] "choice"
        #   set /home/trevor/devel/yocto/gitrepo-method/poky/meta/classes/terminal.bbclass:5
        #     [choices] "auto none ${@" ".join(o.name for o in oe.terminal.prioritized())}"
        # computed:
        #   "screen"
        OE_TERMINAL="screen"

==============================================================================
20. menuconfig

    If I do a

        $ bitbake <kernel> -c menuconfig

    a window pops up and presents me with the kernel's menuconfig.
    Personally I would much prefer if the menuconfig would just come
    up in the existing window in which I am working. Thankfully OE
    already has this functionality, to get it add:

        OE_TERMINAL = "screen"

    to conf/local.conf. [see item #26 too]

    The Yocto documentation recommends doing a:

        $ bitbake <kernel> -c kernel_configme -f

    prior to the "-c menuconfig".

==============================================================================
19. SDK

    As far as I can tell, there are a couple ways to perform cross-development
    relative to a bitbaked image:
        - ADT
        - bitbake -c populate_sdk <image>
        - cross-build a native dev environment
        - manual Makefile

 19.a) ADT

    I don't know anything about this method. I think you use some ADT tool in
    eclipse and it allows you to perform cross-development relative to some
    build.

 19.b) bitbake -c populate_sdk <image>

    When you have successfully completed your build, perform a:

        $ bitbake -c populate_sdk <image>

    then look in

        tmp/deploy/sdk

    and you'll find a self-extracting shell script which you can run anywhere
    (it'll start by asking you where you want to extract your SDK, so the SDK
    doesn't have to be setup in the location where you are presently located):

        $ sh tmp/deploy/sdk/poky-eglibc-x86_64-i586-toolchain-1.3+snapshot-20130123.sh
        Enter target directory for SDK (default: /opt/poky/1.3+snapshot): /install/path
        You are about to install the SDK to "/home/trevor/tmp/sdk".  Proceed[Y/n]?Y
        Extracting SDK...done
        Setting it up...done
        SDK has been successfully set up and is ready to be used.

    To use the SDK you'll need to source its environment, e.g. (note:
    /some/path is the location into which you asked the SDK to be installed):

        $ source /some/path/environment-setup-i586-poky-linux

 19.c) meta-toolchain

    There is a recipe called meta-toolchain which you can invoke to generate
    an SDK:

        $ bitbake meta-toolchain

    This differs from "-c populate_sdk" in that the recipe dictates *exactly*
    what will end up in the SDK, whereas "-c populate_sdk" determines what to
    include in the SDK by looking at the specified <image>.

    There are also a couple other such meta-toolchain* recipes (filtered):

        $ find . -name "*meta-toolchain*" -print
        ./meta-openembedded/meta-efl/recipes-core/meta/meta-toolchain-efl.bb
        ./openembedded-core/meta/recipes-core/meta/meta-toolchain-gmae.bb
        ./openembedded-core/meta/recipes-core/meta/meta-toolchain.bb
        ./openembedded-core/meta/recipes-qt/meta/meta-toolchain-qt.bb
        ./openembedded-core/meta/recipes-qt/meta/meta-toolchain-qte.bb
        ./meta-poky/meta/recipes-core/meta/meta-toolchain-gmae.bb
        ./meta-poky/meta/recipes-core/meta/meta-toolchain.bb
        ./meta-poky/meta/recipes-qt/meta/meta-toolchain-qt.bb
        ./meta-poky/meta/recipes-qt/meta/meta-toolchain-qte.bb

    The result ends up in tmp/deploy/sdk.

 19.d) cross-build a native development environment

    You can create an image that includes all the development tools and
    packages for development. If you run this image on the target device
    and/or in a virtual instance you can use that setup for your development
    work.

    You have to create a separate image from your target image (assuming you
    don't want to deploy an image with all the build/development tools). In
    this -dev image, modify the configuration's EXTRA_IMAGE_FEATURES (or
    perhaps just 'IMAGE_FEATURES += '?) to include some or all of the
    following:

        dbg-pkgs        add -dbg packages of everything
        dev-pkgs        add -dev packages of everything
        tools-sdk       add development tools (gcc, make, ...)
        tools-debug     add debugging tools (gdb, strace, ...)
        tools-profile   add profiling tools (oprofile, valgrind, ...)
        tools-testapps  add useful testing apps

    Some images already come with a -dev variation (for example
    core-image-minimal and core-image-minimal-dev).

    Note: meta/recipes-core/images/core-image-minimal-dev.bb just simply
    includes:

        require core-image-minimal.bb
        DESCRIPTION = "..."
        IMAGE_FEATURES += "dev-pkgs"

 19.e) manual Makefile

    You can create a Makefile by hand for your project and include things such
    as (this example is specific to gumstix development):

        OETMP = /path/to/your/build/directory/tmp
        TOOLDIR = $(OETMP)/sysroots/`uname -m`-linux/usr/bin
        STAGEDIR = $(OETMP)/sysroots/<machine>/usr
            [e.g. $(OETMP)/sysroots/overo/usr]
        CC = $(TOOLDIR)/armv7ahf-vfp-neon-poky-linux-gnueabi/arm-poky-linux-gnueabi-gcc
        CFLAGS = -O2 -Wall -mfloat-abi=hard -mfpu=vfp
        LIBDIR = $(STAGEDIR)/lib
        INCDIR = (STAGEDIR)/include

        <target>: <dependencies>
            $(CC) $(CFLAGS) -I $(INCDIR) -L $(LIBDIR) ...

==============================================================================
18. Image package list

    To obtain the list of packages that are going to be included in a given
    image use bitbake's '-g' option with the image name:

        $ bitbake -g <image>

    then

        $ cat pn-buildlist | grep -v native | sort

==============================================================================
17. Notes for imx53qsb

    a) the older way
    - include meta-fsl-arm layer
    - set MACHINE to imx53qsb
    - 'dd' sdcard image to a flash card:
        # dd if=tmp/deploy/images/core-image-minimal-imx53qsb.sdcard of=/dev/sdd

    b) a newer way using the fsl code at github
        $ repo init \
            -u https://github.com/Freescale/fsl-community-bsp-platform \
            -b dylan
        $ repo sync
        $ source ./setup-environment <build directory name>
        $ MACHINE="imx53qsb" bitbake fsl-image-gui
            (use the same 'dd' command to create the sdcard)

==============================================================================
16. Notes on setting up an ssh server in an image

    If you decide you want to ssh to a _development_ image and are using
    'runqemu', you'll notice the IP address of the image will always be the
    same (192.168.7.2). However, each new build of the image will cause new
    server SSH keys to be generated. This means that between 'runqemu' runs
    you will have to run something like the following:

        $ ssh-keygen -R 192.168.7.2 -f $HOME/.ssh/known_hosts

    In order to clear out your local settings (which will cache the current
    host keys and notice the change when your next image is generated). Since
    you know these images are safe, put the following into your
    $HOME/.ssh/config:

        Host 192.168.7.2
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            User root

    This way you only need to:

        $ ssh 192.168.7.2

    to ssh into the running image, and you will not be required to run the
    'ssh-keygen -R' line between connecting to new images.

    In order to add an ssh server to your image, simply add the following
    option to your configuration:

        EXTRA_IMAGE_FEATURES ?= "debug-tweaks ssh-server-openssh"

    You probably already have the "debug-tweaks" option, so all you'll simply
    need to do is add the "ssh-server-openssh" option. The combination of
    these two things builds the ssh server into your image, runs it on
    startup, and tweaks the ssh server configuration so that it allows
    password-less root logins.

==============================================================================
15. Setting the size of an image

    The size of an image is calculated in

        poky/meta/classes/image_types.bbclass

    as follows:

        runimagecmd ()
            # Image generation code for image type ${type}
            # The base_size gets calculated:
            #  - initial size determined by `du -ks` of the IMAGE_ROOTFS
            #  - then multiplied by the IMAGE_OVERHEAD_FACTOR
            #  - tested against IMAGE_ROOTFS_SIZE
            #  - round up ROOTFS_SIZE to IMAGE_ROOTFS_ALIGNMENT

    Yocto is very smart with image sizes, it is able to calculate the size of
    the image dynamically so that you'll never end up with a build which fails
    simply because the image expands beyond some (random, buried) hard-coded
    value of what the image size should be (several image-creation tools
    require the image size to be specified upfront, by calculating this size
    on the fly Yocto avoids a silly build failure).

    After determining the image size, Yocto adds a little headroom and
    builds the image based on those numbers. To increase the overhead
    specify (for example):

        IMAGE_OVERHEAD_FACTOR = "10"

    or you could play with the IMAGE_ROOTFS_SIZE. To set the size for all
    output images use (for example):

        IMAGE_ROOTFS_SIZE = "8192"

    Another suggestion is to just set IMAGE_ROOTFS_EXTRA_SPACE (in kb).

    NOTE: vmdk's grow dynamically, so although the final .vmdk won't
          be the size specified, it will be able to grow to that size when
          running. Other output image types (e.g. ext3) will be created of
          the requested size.

    NOTE: to build a vmdk image, internally other image types have to be
          enabled too, so you'll see them in your tmp/deploy/images area

    NOTE: the build system will set your image size to be the larger of its
          calculated size and the size you specify. Therefore if you set
          IMAGE_ROOTFS_SIZE too small, the system will bump up the output
          size silently.

    NOTE: the value you specify for IMAGE_ROOTFS_SIZE is in [KB], therefore
          "8192" is an 8[MB] image.

==============================================================================
14. Ignoring .bbappends with no .bb

    Sometimes you'll add a layer, start your build, and get:

        No recipes available for:
            /home/trevor/devel/yocto/git-method/poky/meta-openembedded/meta-oe/recipes-qt/qt4/qt4-x11-free_4.8.4.bbappend
            /home/trevor/devel/yocto/git-method/poky/meta-openembedded/meta-oe/recipes-qt/qt4/qt4-embedded_4.8.4.bbappend

        In bitbake you can create .bb files which are, generally, recipes. In
        other parts of your configuration, instead of rewriting an entire
        recipe, you can create a .bbappend which will modify the behaviour of
        a previously defined .bb file. Sometimes a .bbappend file exists and
        bitbake can't find the matching .bb to modify. By default bitbake
        assumes there is a mistake in your configuration somewhere (i.e. you
        probably forgot to add a layer or something). Sometimes this is
        not a mistake. To get bitbake to just issue a warning but otherwise
        continue with the build (by default a build would stop with an error
        at this point) add the following to your configuration:

            BB_DANGLINGAPPENDS_WARNONLY = "yes"

==============================================================================
13. Ignoring certain configuration items

    To get bitbake to ignore certain recipes/paths/layers/patterns edit/set
    a BBMASK variable in your configuration.

    Since 2.1 it's easier and safer to construct BBMASK as a set of
    space-separated expressions rather than trying to append to a single
    regex.

    e.g.

        BBMASK += "qemu_qoriq.bb"

==============================================================================
12. To obtain a list of supported output image types

    Look in "poky/meta/classes/image_types.bbclass" for "IMAGE_TYPES":

        # This variable is available to request which values are suitable for IMAGE_FSTYPES
        IMAGE_TYPES = "jffs2 sum.jffs2 cramfs ext2 ext2.gz ext2.bz2 ext3
        ext3.gz ext2.lzma btrfs live squashfs squashfs-lzma ubi tar tar.gz
        tar.bz2 tar.xz cpio cpio.gz cpio.xz cpio.lzma vmdk elf"

    To pick one or more images to generate, edit/create IMAGE_FSTYPES somewhere
    in your configuration. For example, edit conf/local.conf and add:

        IMAGE_FSTYPES = "vmdk"

==============================================================================
11. Recipe dependency information

    A couple really nice ways to see recipe dependency information are:

        for a full gui tool:
            $ bitbake -u taskexp -g <image>

        or for just plain text files:
            $ bitbake -g <image>

    NOTE: "taskexp" used to be "depexp"

==============================================================================
10. How to restart the build when a recipe fails

    $ bitbake -c clean <recipe>
    $ bitbake <image>

==============================================================================
 9. How to modify the autotool ./configure options

    A forceful (but bad way) to modify the ./configure options for the
    configure step of a recipe's build is to edit the recipe's *.bb file
    and add/edit EXTRA_OECONF variable. E.g.:

        EXTRA_OECONF = "--disable-docs"

==============================================================================
 8. How to add packages to an image

    Edit local.conf and add the packages to add. For example to add bash,
    openssh, openss-ssh, openssh-sshd and util-linux:

        CORE_IMAGE_EXTRA_INSTALL += "bash openssh openssh-ssh openssh-sshd util-linux"

    It is important to know that in Yocto/OpenEmbedded terminology we are given
    'recipes' and these 'recipes' generate 'packages'. Packages are files which
    contain the products of a compile. When you compile some source you find on
    the internet and perform a 'make install', lots of stuff gets installed to
    the $DESTDIR/$prefix location. In many cases, lots of this stuff isn't
    needed in an image. Examples of files installed during a 'make install'
    might include headers, man/info pages, language files, development
    libraries, tests, utility programs (i.e. to generate a configuration file),
    server binaries, client binaries, etc. In order to make it easier to just
    include only the files you want in an image, a good bitbake 'recipe' will
    generate multiple 'packages'; you then select only the packages you want
    included in your image.

    Notice that the things you specify in "CORE_IMAGE_EXTRA_INSTALL" are
    _packages_ and not _recipes_.

    To figure out which packages are created by a specific recipe:

        $ bitbake -e <recipe> | grep "^PACKAGES="

    $ bitbake -e python | grep "^PACKAGES="
    PACKAGES="libpython2 python-dbg python-2to3 python-audio python-bsddb
    python-codecs python-compile python-compiler python-compression
    python-core python-crypt python-ctypes python-curses python-datetime
    python-db python-debugger python-dev python-difflib
    python-distutils-staticdev python-distutils python-doctest
    python-elementtree python-email python-fcntl python-gdbm
    python-hotshot python-html python-idle python-image python-io
    python-json python-lang python-logging python-mailbox python-math
    python-mime python-mmap python-multiprocessing python-netclient
    python-netserver python-numbers python-pickle python-pkgutil
    python-pprint python-profile python-pydoc python-re python-readline
    python-resource python-robotparser python-shell python-smtpd
    python-sqlite3 python-sqlite3-tests python-stringold python-subprocess
    python-syslog python-terminal python-tests python-textutils
    python-threading python-tkinter python-unittest python-unixadmin
    python-xml python-xmlrpc python-zlib python-modules python-misc
    python-man"

    In order to find out which recipes are available (this varies depending
    on which version of the Yocto Project you are using as well as which
    layers you have added in your 'bblayers.conf' file):

        $ bitbake -s

    or

        $ bitbake-layers show-recipes


    Can't I just use:

        IMAGE_INSTALL_append = " bash"

    instead of:

        CORE_IMAGE_EXTRA_INSTALL += "bash"

    ? Well, yes. But the whole "don't forget the space" and "make sure you use
    '_append = " <package>"' and not '+= "<package"' (or any other variation)
    was getting confusing and people are constantly making mistakes with it.
    So the prevailing attitude is that the safest thing to advise people is to
    use this new variable instead of appending to an already-defined variable.

    To add the kernel modules to an image:

        CORE_IMAGE_EXTRA_INSTALL += "kernel-modules"


==============================================================================
 7. How to build an image with an -rt kernel

    building qemux86 -rt (i586)

    edit local.conf and add:

        PREFERRED_PROVIDER_virtual/kernel = "linux-yocto-rt"

    Sometimes the above will just cause bitbake to complain that your MACHINE
    isn't in the COMPATIBLE list (or something like that), in which case you
    also need to add:

        COMPATIBLE_MACHINE_<machine> = "<machine>"

    e.g.

        COMPATIBLE_MACHINE_beaglebone = "beaglebone"

    $ bitbake core-image-rt
    $ runqemu qemux86 tmp/deploy/images/core-image-rt-qemux86.ext3

    NOTE: that it is not necessary to use the "core-image-rt" target in order
    to build a kernel with -rt if you've already configured your build to use
    an -rt kernel. This target simply adds more "-rt" things in the image.

==============================================================================
 5. Quick start instructions

    $ mkdir -p /home/trevor/devel/yocto/git-method
    $ cd /home/trevor/devel/yocto/git-method
    $ git clone git://git.yoctoproject.org/poky

    $ cd poky
    $ git clone git://git.yoctoproject.org/poky-extras poky-extras
    $ git clone git://git.yoctoproject.org/meta-intel.git
    (see http://www.openembedded.org/wiki/LayerIndex for more)

    $ cd ..
    $ source poky/oe-init-build-env 
    (this creates and puts you into a directory named "build" by default,
    you can change the target dir by specifying it at the end of the previous
    line)

    You had no conf/local.conf file. This configuration file has therefore been
    created for you with some default values. You may wish to edit it to use a 
    different MACHINE (target hardware) or enable parallel build options to take 
    advantage of multiple cores for example. See the file for more information as 
    common configuration options are commented.

    The Yocto Project has extensive documentation about OE including a reference manual
    which can be found at:
        http://yoctoproject.org/documentation

    For more information about OpenEmbedded see their website:
        http://www.openembedded.org/

    You had no conf/bblayers.conf file. The configuration file has been created for
    you with some default values. To add additional metadata layers into your
    configuration please add entries to this file.

    The Yocto Project has extensive documentation about OE including a reference manual
    which can be found at:
        http://yoctoproject.org/documentation

    For more information about OpenEmbedded see their website:
        http://www.openembedded.org/



    ### Shell environment set up for builds. ###

    You can now run 'bitbake <target>'

    Common targets are:
        core-image-minimal
        core-image-sato
        meta-toolchain
        meta-toolchain-sdk
        adt-installer
        meta-ide-support

    You can also run generated qemu images with a command like 'runqemu qemux86'

    $ vi conf/local.conf
        edit:
            BB_NUMBER_THREADS
            PARALLEL_MAKE
            MACHINE
            DL_DIR
        add:
            NO32LIBS = "1" (only necessary if glibc-devel-32 is installed on a 64-bit system)

    $ bitbake core-image-minimal

==============================================================================
 4. How can I just grab all the necessary files from the net?

    OLD:
        $ bitbake -c fetchall <target-image>

    newer/more recent:
        $ bitbake <target/image> --runall fetch

==============================================================================
 3. What images are available from which to choose?

    a) have a look at the manual:
        http://www.yoctoproject.org/docs/current/poky-ref-manual/poky-ref-manual.html#ref-images

    b) From within the poky Git repository, use the following command to list the
       supported images:

        $ ls */*/images/*bb

       These recipes reside in the meta/recipes-core/images,
       meta/recipes-extended/images, meta/recipes-graphics/images, and
       meta/recipes-sato/images directories of your local Yocto Project
       file structure (Git repository or extracted release tarball).

==============================================================================
 2. General task list

    do_fetch
    do_unpack
    do_patch
    do_configure
    do_compile
    do_install
    do_package

==============================================================================
 1. How to obtain the list of tasks

    $ bitbake -c listtasks <image>
    Parsing recipes: 100%
    |##################################################################|
    Time: 00:00:15
    Parsing of 828 .bb files complete (0 cached, 828 parsed). 1127
    targets, 19 skipped, 0 masked, 0 errors.

    Build Configuration:
    BB_VERSION        = "1.15.3"
    TARGET_ARCH       = "i586"
    TARGET_OS         = "linux"
    MACHINE           = "qemux86"
    DISTRO            = "poky"
    DISTRO_VERSION    = "1.2+snapshot-20120816"
    TUNE_FEATURES     = "m32 i586"
    TARGET_FPU        = ""
    meta
    meta-yocto        = "master:af847d36375aa53f0c1ee2a00c97ba9f38837d1b"

    NOTE: Resolving any missing task queue dependencies
    NOTE: Preparing runqueue
    NOTE: Executing RunQueue Tasks
    do_fetchall
    do_build
    do_devshell
    do_cleansstate
    do_rootfs
    do_configure
    do_cleanall
    do_populate_lic
    do_package_write
    do_populate_sysroot
    do_populate_sdk
    do_package_write_rpm
    do_unpack
    do_patch
    do_listtasks
    do_compile
    do_package_setscene
    do_populate_lic_setscene
    do_fetch
    do_checkuri
    do_clean
    do_package_write_rpm_setscene
    do_package
    do_install
    do_populate_sysroot_setscene
    do_checkuriall
    NOTE: Tasks Summary: Attempted 1 tasks of which 0 didn't need to be rerun and all succeeded.
